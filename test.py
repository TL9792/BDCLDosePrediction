import shutil
import sys, os
import numpy as np
import time
import torch
import torch.backends.cudnn as cudnn
import torch.nn as nn
import torch.nn.functional as F
from torch import optim
from torch.utils import data
import pandas as pd
import SimpleITK as sitk
from Network.BeamDoseNetwork.ResUnet import RUNet,RUnet_encoder,RUnet_decoder
from provided_code.data_loader import KBPDataset
from Evalutaion.DoseScoreDVHScore import EvaluateDose
from provided_code.general_functions import get_paths, make_directory_and_return_path, sparse_vector_function
from MultiBeamVoting import reconstruct
import pdb
from torch.utils.tensorboard import SummaryWriter 

#### test stage
if __name__ == '__main__':
  

    testing_data_dir = "Data/test-pats/"
    best_model_path = ''
    # Define project directories
    # TODO: Must define the path of where the data is stored.
    primary_directory = '{}'.format(sys.path[0])
    print(torch.cuda.is_available(), os.environ['CUDA_VISIBLE_DEVICES'])
    # path where any data generated by this code (e.g., predictions, models) are stored
    results_dir = '{}/result'.format(primary_directory)
    os.makedirs(results_dir, exist_ok=True)

    # Name model to train and number of epochs to train it 
    number_of_training_epochs = 1
    epoch_num = 1000   
    batch_size = 2
    lr = 1e-4
    num_workers = 12
    dose_scale_factor = 80.0
    ct_range = [600,1400]
    en = RUnet_encoder(13,9,16)
    de = RUnet_decoder(13,9,16)
    model = RUNet(en,de)
    net = nn.DataParallel(module=model)
    net.cuda()
    model_name = net.module.model_name()
    model_desc = sys.argv[1]

    # Prepare the data directory
    test_data_paths = get_paths(testing_data_dir, ext='') 

    # Make directories for data and models
    model_results_path = '{}/{}_{}'.format(results_dir, model_name, model_desc)
    test_imgs_dir = make_directory_and_return_path('{}/test-results-images'.format(model_results_path))

    ## load data
    dataset_test = KBPDataset(test_data_paths, flipped=False, rotate=False, noise=False, deformation=False, ct_range=ct_range)
    data_loader_test = data.DataLoader(
            dataset=dataset_test, batch_size=batch_size, shuffle=False, pin_memory=True, drop_last=False, num_workers=num_workers)


    net.load_state_dict(torch.load(best_model_path)['model_state_dict'])
    net.eval()
    test_evaluator = EvaluateDose(dataset_test)
    n = 0
    for batch_id, batch in enumerate(data_loader_test):
        # fetch data
        img = batch['ct']
        roi = batch['structure_masks']
        ptv = batch['ptv']
        oar = batch['oar']
        direction_mask = batch['directions']
        gt_dose = batch['dose'] / dose_scale_factor
        coarse_dose = batch['coarse_dose'] / dose_scale_factor
        direction_gt = direction_mask * gt_dose
        dose_mask = batch['possible_dose_mask']
        spacing = batch['voxel_dimensions']
        pat_id = batch['patient_id']
        n = len(img)

        # convert to GPU memory
        img = img.cuda()
        roi = roi.cuda()
        ptv = ptv.cuda()
        oar = oar.cuda()
        direction_gt = direction_gt.cuda()
        gt_dose = gt_dose.cuda()
        direction_mask = direction_mask.cuda()
        coarse_dose = coarse_dose.cuda()

        # forward propagation
        pd_dose = net(torch.cat([img, ptv, oar, coarse_dose, direction_mask], dim=1).float())
        pd_dose = pd_dose * direction_mask

        reimg = reconstruct(pd_dose,coarse_dose)
        reimg = reimg.data.cpu().numpy().copy()
        gt_dose = gt_dose.data.cpu().numpy().copy()
        reimg = reimg * dose_scale_factor
        gt_dose = gt_dose * dose_scale_factor
        error_map = np.abs(reimg-gt_dose)

        test_evaluator.append_sample(reimg, batch, gt_dose)

        # store the output prediction
        for i in range(reimg.shape[0]):
            spacing = tuple(batch['voxel_dimensions'][i].numpy().copy()[...,[2,1,0]])
            new_pd = sitk.GetImageFromArray(np.flip(np.squeeze(reimg[i]),0))
            new_pd.SetSpacing(spacing)
            new_gt = sitk.GetImageFromArray(np.flip(np.squeeze(gt_dose[i]),0))
            new_gt.SetSpacing(spacing)
            new_error = sitk.GetImageFromArray(np.flip(np.squeeze(error_map[i]),0))
            new_error.SetSpacing(spacing)
            sitk.WriteImage(new_pd, test_imgs_dir+'/pred_{}.nii.gz'.format(pat_id[i]))
            sitk.WriteImage(new_gt, test_imgs_dir+'/gt_{}.nii.gz'.format(pat_id[i]))
            sitk.WriteImage(new_error, test_imgs_dir+'/error_{}.nii.gz'.format(pat_id[i]))

        # Prepare the dose to save
        print('Progress {0:5.2f}% (+1) --- {1:s}'.format(100.0 * n / len(dataset_test), pat_id[0]))
        n += 1

    # calculate the test score
    dvh_score, dose_score = test_evaluator.make_metrics()
    print('Testing result:\n'
    '\tthe DVH score is {:.3f}\n '
    '\tthe dose score is {:.3f}'.format(dvh_score, dose_score))

